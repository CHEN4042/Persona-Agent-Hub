## 1. **你可以先介绍一下你对网关这个地方的理解吗?** 



## 2. **你刚刚提到的那个就是网关它会包括对你进行流量分配吗?**

从面试官的提问来看，他们关注的是网关是否具备负载均衡和流量分配功能，这涉及到网关在流量管理中的作用。以下是改进回答的建议：

**示例回答**

> **"是的，API网关在API开放平台中不仅可以对流量进行转发，还能够实现负载均衡和流量分配。我们通过Spring Cloud Gateway与Nacos注册中心集成，使得网关可以实时感知后端服务的变化，进行动态路由和负载均衡。**
>
> **在负载均衡策略上，我们可以采用轮询、最小连接数等常见策略，保证流量能够均匀分配到不同的后端实例中，提升系统的可靠性和并发能力。网关还能基于自定义过滤器对请求进行限流或流量染色，确保在高峰流量下系统的稳定性。通过这种方式，网关成为了API请求的调度中心。"**

## 3. 那你的服务是怎么在机器上进行部署的?

**建议的改进回答**

> **“服务的部署流程是这样的：我们使用Nacos作为注册中心，所有的服务（包括网关服务）在启动时会将自身注册到Nacos中，这样其他服务可以通过Nacos进行服务发现，动态获取目标服务的地址和端口信息。网关作为独立的服务应用，通过Nacos注册和发现机制找到目标服务，并使用Dubbo（或其他RPC框架）进行远程调用。RPC的调用方式让我们可以像调用本地方法一样调用远程服务，实现服务间高效、低延迟的通信。”**

## 4. **你刚刚聊到的那个注册中心嘛,那个Zookeeper可以了解到吗?**

### **建议的改进回答**

> **“Zookeeper确实可以作为注册中心，但我们选择了Nacos，主要是因为它在微服务场景下更具优势。Nacos不仅支持服务注册与发现，还提供了配置管理的功能，且自带一个友好的控制台，方便实时查看服务状态。Nacos学习成本相对较低，比较适合我们这样的小型项目。而Zookeeper主要用于分布式协调，对于服务治理的支持不如Nacos灵活。”**

## 5. 了解过Nacos中的那个RAP的那个选举机制吗

### 建议的改进回答示例

> **“RAP 或者 Raft 的选举机制主要用于分布式系统中的一致性控制，确保在集群中选出唯一的 Leader。Nacos 确实有类似的选主机制，但它默认使用的是 Distro 协议，特别适合服务注册和发现的高可用性需求。Distro 更偏向于 AP 场景，保证系统的可用性。对于配置管理等对一致性要求较高的场景，Nacos 也提供 Raft 类似的协议来保障一致性。”**

## 6. 项目中还有什么亮点吗

### SDK

> “在这个项目中，我个人认为比较有亮点的开发工作是利用 Spring Boot Starter 开发了一个 SDK 并发布到 Maven 仓库。这个 SDK 的设计目标是将接口调用的逻辑封装到一个可复用的库中，简化用户调用 API 的复杂度。主要的挑战是如何抽象接口，以适应未来的扩展。每次我们在后端增加接口时，我都会重新打包 SDK 并发布新版本，让用户可以直接通过 Maven 更新到最新的接口集成。在自动化方面，我也考虑过是否可以通过 API 自动生成 SDK 代码，比如利用 OpenAPI 生成器来减少人工更新的工作量，从而提升 SDK 的维护效率。”

**API签名认证**

> API 签名认证算法是一种用于验证 API 请求的合法性和完整性的安全机制。
> 给接口使用 API签名认证算法，可以增强 API 的安全性，防止未经授权的用户访问、防止恶意用户篡改请求数据。
> 实现步骤如下：
>
> 1. 生成密钥对：给每个用户生成唯一的密钥对（accessKey 和 secretKey），并保存到数据库中，仅用户本人可查看自
>    己的密钥对。
> 2. 请求方生成签名：请求方（客户端）使用 secretKey 对请求参数和数据进行签名，签名的内容包括请求参数、时间
>    戳、随机数等，签名加密算法此处选择 MD5。
>    3.请求方发送请求：请求方将请求参数、签名、用户标识一起发送给 API 提供者，通常会把签名等元信息放到请求头参
>    数中传递，注意千万不要传递 secretkey。
>    4.API提供者验证签名：在API 网关中，通过请求头获取到用户标识，根据标识到数据库中查找该用户对应的 accessk
>    ey 和 secretKey，并使用相同的签名算法生成签名，和请求中的签名进行比对，如果签名一致，则API 提供者可以信
>    任请求方，可以进行后续操作。

## 7. AK和SK被盗了怎么办

**改正后的回答示例：**

> “如果数据库被盗，我们主要依赖于加密存储和密钥管理机制来降低泄露风险。首先，AK 可以直接存储，但 SK 则会使用高级加密算法（如 AES、SHA-256）来进行加密存储。即便数据库被盗，攻击者也很难直接破解 SK 的值。
>
> 此外，我们会定期检查 SK 的访问情况，防止异常调用。如果发生数据库泄露事件，可以通过旋转（重置）用户的 AK 和 SK，并提醒用户更新密钥，这样可以降低安全风险。一般情况下，我们也推荐用户设置 IP 白名单和请求频率限制来进一步保障安全。”

### 解释要点

1. **SK 的加密存储**
   - 使用加密算法存储 SK，即便数据库被盗，也难以破解密钥。
2. **AK 和 SK 的旋转机制**
   - 当泄露发生时，可以通过重置 AK 和 SK 进行补救，防止密钥长期被滥用。
3. **额外的安全防护**
   - IP 白名单、请求频率限制和日志监控等，可以对访问情况进行分析和防护，进一步提高安全性。

## 8. MySQL 中的隔离级别

## 9. 讲一讲ACID 

## 10. ACID 特性的具体实现

“在 MySQL 中，**原子性** 是通过事务日志（如 redo log 和 undo log）来实现的。具体来说：

- 当事务执行时，数据库会先写入 redo log（重做日志）以确保事务操作的持久性。
- undo log（回滚日志）记录的是事务修改前的状态，一旦事务失败，数据库可以利用 undo log 将数据恢复到事务执行前的状态。
- 这种机制确保了事务要么完全执行成功，要么失败后完全回滚，从而保证了原子性。”

## 11. MVCC你知道它是怎么实现的吗

## 12. B树跟B加树的区别是什么?

## 13. 什么数据库使用 B+ 树而不是红黑树？

## 14. 讲一讲数据库性能调优



## 15. 什么时候需要分库分表



## 16. Redis的淘汰策略



## 17. 淘汰策略中的lru到底是怎么实现的



## 思考题： "盒子和囚犯问题"。

简单来说，100名囚犯轮流进入房间，选择最多50个盒子，如果每名囚犯都能在50次尝试中找到属于自己的编号，则所有人都成功，否则失败。这个问题的关键在于找到所有人都成功找到自己编号的概率。

**问题中的成功概率分析**

在这种策略下，成功的概率约为 **31%**。这是因为，对于100个盒子，编号形成的随机排列通常会有短的循环和一些较长的循环。如果所有循环都短于50，那么囚犯们成功找到自己编号的概率就是这个31%左右。

**直观解释成功原因**

通过“循环追踪法”，囚犯们会沿着每个编号指引的路径进行查找。如果形成的循环长度都不超过50次，那么每个囚犯都会在50次尝试中找到自己的编号；而如果有任意一个循环的长度超过50，则囚犯失败。这种策略并不保证100%成功，但相较于随机选择50个盒子的策略，该策略显著提升了成功的可能性。



## 算法题： [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)