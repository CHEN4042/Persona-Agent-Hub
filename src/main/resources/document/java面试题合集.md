# Java基础

## Java**⾯对对象的三个基本特征**

封装：封装是指对数据和⽅法的⼀个私有化，通过隐藏对象的内部实现细节，防⽌⽆关⼈员错误改变对象的私有部分。

继承：允许⼦类重⽤⽗类的代码并进⾏功能扩展，⽆需重新编写原有类。

多态：多态允许将⽗对象设置为与⼀个或多个其⼦对象相等，赋值后，⽗对象可以根据当前赋值给它的⼦对象的特性以不同的⽅式运作。



## Java**有哪些数据类型？**

![image-20241107121135167](java面试题合集.assets/image-20241107121135167.png)

不同集合的特点

（1）List 特点：有序、可重复

（2）Set 特点：⽆序、不可重复

（3）Collection 特点：⽆序、可重复

（4）Map 特点：⽆序，不可重复，存放【键值对】（key 键 -- value 值）



## ArrayList**和**LinkedList**有什么区别？**

最明显的区别是 ArrrayList 底层的数据结构是动态数组，⽀持随机访问，⽽ LinkedList 的底层数据结构是链表，不⽀持随机访问。由于底层结构不同，他们所适⽤的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加。

ArrayList的下标查询复杂度是O(1)，其他查找是O(n),⽽LinkedList不⽀持下标查询，它的头节点查询是O(1)，其他节点需要遍历是O(n)。



## Hashmap**的实现原理**

HashMap的底层数据结构是hash表数据结构，即数组加上链表或者红⿊树

添加数据时，会利用keyhashcode值重新计算hash值来确定元素在数组中的下标

如果出现hash值相同的key (hash冲突)

\- Key相同则替换

\- 不同则存⼊链表或者红⿊树

![image-20241107124506154](java面试题合集.assets/image-20241107124506154.png)

同时HashMap在jdk1.7和jdk1.8的区别

\- jdk1.8之前采⽤拉链法，使⽤数组+链表

\- jdk1.8之后采⽤数组+链表+红⿊树，**链表⻓度超过8且数组⻓度超过64的链表会被转换成红⿊树**



## Hashmap**的**put**⽅法的具体实现**

put时，⾸先判断是否为空，如果是空就调⽤hashmap的初始化流程。如果不为空则进⾏hashmap的扩容判断



## 什么时候会使用红黑树来优化 HashMap 的性能？

- **查找速度**：红黑树是一个自平衡二叉树，所以可以保证O(logn)的速度。而遍历链表是 O(n)
- **动态转换**：`HashMap` 会在以下两种情况之间动态转换：
  - **链表转红黑树**：当某个桶中的链表长度超过 8 时，将链表转换为红黑树。
  - **红黑树转链表**：当该桶的元素数量减少到 6 以下时（例如，通过删除操作），会将红黑树重新转回链表结构。这样可以减少小数据集情况下的内存开销。



## Hashmap的寻址算法

计算对象的hashcode()

在进行调用hash() 方法进行二次哈希，hashcode值右移16位再异或运算，让哈希分布更为均匀

最后(capacity-1) & hash得到索引

## 谈一谈ConcurrentHashmap

ConcurrentHashmap 就是内部加锁的hashmap，因为加上了锁所以实现了线程安全

底层采用了CAS的自旋锁和synchronized锁关键字来保证并发安全

- JDK1.7采用Segment分段锁，底层使用的是ReentrantLock
- JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑二又树的首节
  点，相对Segment分段锁粒度更细，性能更好

![QQ_1730955985481](java面试题合集.assets/QQ_1730955985481.png)



## ArrayList **和**Hashmap**的初始容量和扩容机制**?

ArrayList 的初始容量是0，当第⼀次添加数据的时候才会初始化为10个元素，每次扩容都是原来容量的1.5倍，每次扩容都需要拷⻉数组

Hashmap的初始容量是16，hashmap有个扩容阀值（数组容量*加载因⼦）当超过阈值的时候会触发扩容，每次扩容都会乘以2并赋值给新数组

## **如何将⼀个集合实现类变成线性安全的类**

1. 在⽅法内使⽤，局部变量是线程安全的
2. 使⽤Collections包装成线程安全（互斥锁）

使⽤Collections包装成线程安全，本质上是将原本的集合在执⾏之前加上了synchronized(){}的对象锁，将对象先锁定再来运⾏。⽐如Collections.synchronizedList， Collections.synchronizedSet

3. 使⽤concurrent包装成线程安全（读写锁）

⽐如CopyOnWriteArrayList如果是读操作，和普通的ArrayList没有区别，如果是写操作，会先上锁，上锁后将数据复制⼀份，再将数据写⼊，避免数据覆盖⽽造成的数据问题。

## **哪些集合可以存放**Null**值**

List中全部可以存null

ArrayList 可以存null

LinkedList 可以存null

Queue队列中

- 只有LinkedList 可以存null Deque是Queue的⼦接⼝

Map中

- HashMap允许存null

- LinkedHashMap 允许存nullTreeMap 不允许存null

- Hashtable不允许存null

Set

- HashSet、LinkedSet可以
- TreeSet 不允许存null



## == **和** equals **区别是什么？**

== 和 equals 如果不重写的话则是⼀样的，⼆者⽐较的是值（基本数据类型⽐较值，引⽤数据类型⽐较地址值）

```java
public calss Object{
  public boolean equals(Object obj){
  	return (this == object)
	}
}
```

但是如果我们使⽤时string 和包装类型等override了equals⽅法的类型，由于equals被重写了，可以实现字符串⽐较等新功能，所以不同。

## **为什么要重写**hashcode**（）**

在重写equals的时候，我们通常也会重写hashcode.

因为，重写hashcode能确保相同对象的索引值相等(也就是键在哈希表中存放的位置)。如果我们只重写equals，确实存储会变成⼀个对象，但是hashcode计算出的索引就有可能是两个，导致⼀个对象在两个位置存储了。

## String**，**String builder**，**String buffer**之间的区别**

不可变字符串：String是只读字符串，不可改变

可变字符串：String builder，String buffer都是字符串拼接的⽅法

其中String builder是线程不安全的，String buffer是线程安全的，它使⽤了synchronized锁来保证每次对字符串的操作都是安全的，但是性能⽐较低

## **序列化和反序列化**

原因：

1. ⽹络传输：⽹络传输的数据都必须是⼆进制数据，但是在java中都是对象，是没办法在⽹络中传输的，所以需

要对java对象进⾏序列化。

2. 对象持久化：将内存中的对象状态保存到⽂件或者数据库中实现：
3. Java原⽣序列化：通过实现Serializable接⼝，可以通过ObjectOutputSteam中的操作来进⾏
4. 使⽤第三⽅的序列化：⽐如使⽤JSON，Hessian等



## **抽象和接⼝的区别**

抽象类（Abstract Class）

- 抽象类可以包含抽象⽅法和具体⽅法。

- ⼦类必须实现抽象类中的所有抽象⽅法，除⾮⼦类也是抽象类。

- 主要⽬的是通过抽象增加代码复⽤度

- 只能单⼀继承

接⼝（Interface）

- 接⼝中的⽅法默认是抽象的，不能包含具体的实现。

- 类可以实现多个接⼝，但是只能继承⼀个类。

- 可以多个实现





#  Java **多线程**

## 进程的通信方式

- **消息队列（Message Queue）**

  - **特点**：消息队列提供一种先进先出（FIFO）的消息存储机制。进程可以向队列中放入消息或读取消息，实现异步通信。

  - **实现方式**：通常操作系统提供的API来实现，比如POSIX消息队列或System V消息队列。

  - **优缺点**：消息队列可以在多个进程之间进行通信，且支持无亲缘关系进程，但性能可能低于共享内存和管道。

- **套接字（Socket）**

  - **特点**：套接字是一种跨网络的通信方式，但也可以用于同一主机内的进程通信（如本地套接字）。支持TCP和UDP协议。
  - **实现方式**：基于IP和端口号实现通信，进程通过套接字读写数据。
  - **优缺点**：适用于分布式系统、不同主机间的通信，但相对于其他方式性能较低，数据传输复杂度较高。

- **共享内存（Shared Memory）** 最快

  - **特点**：多个进程共享同一块内存区域，直接读取或写入数据。共享内存是最快的进程通信方式之一，因为数据无需经过系统调用而直接共享。
  - **实现方式**：POSIX共享内存（`shm_open`）和System V共享内存（`shmget`）。
  - **优缺点**：性能高、实现简单，但需要同步机制来确保数据一致性，例如使用信号量（Semaphore）或互斥锁。

## **创建线程的**4**种⽅式**

1. **继承Thread类，并重写run方法**

   - 首先定义一个类来继承Thread类，重写run方法
   - 创建这个子类对象，并调用start方法启动线程

2. **实现Runnable类，并实现run方法**

   - 首先定义一个类来实现Runnable类，实现run方法
   - 创建Runnable实现类对象，并把它作为target传入Thread的构造函数中，调用start启动线程

   - Runnable接⼝run⽅法**没有返回值**

3. **实现Callable接⼝并使⽤Future Task监控**
   - Callable接⼝call⽅法有返回值，但是需要Future Task来获取结果

4. **使⽤Executor线程池创建线程**

底层任然通过实现Runnable接⼝来创建线程，通过实现Executorservice实例，并且传⼊⼀个Runnable类来创建线程。execute(Runnable)



## 能够详细讲一下Executor线程池创建线程吗

在项目中我使用的是`ThreadPoolExecutor`类来实现自定义线程池的。并通过ArryBlockingQueue来存放任务。

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize,           // 核心线程数
    maximumPoolSize,        // 最大线程数
    keepAliveTime,          // 非核心线程的存活时间
    timeUnit,               // 存活时间的单位
    workQueue,              // 阻塞队列
    threadFactory,          // 线程工厂
    handler                 // 拒绝策略
);

```

- **核心线程数**和**最大线程数**共同控制了线程池的资源使用情况。核心线程始终存活，而非核心线程会在空闲时被回收。

- **阻塞队列**（如`ArrayBlockingQueue`或`LinkedBlockingQueue`）用于存储等待中的任务。队列类型决定了任务等待的方式。

- **线程工厂**用于创建线程，通常用于给线程命名或设置优先级。

- **拒绝策略**用于处理无法接受的任务。Java提供了四种内置策略：`AbortPolicy`（抛出异常）、`CallerRunsPolicy`（由调用线程执行任务）、`DiscardPolicy`（丢弃任务）和`DiscardOldestPolicy`（丢弃最早的任务）。



## 线程池的核心参数和执行原理

![QQ_1730959314252](java面试题合集.assets/QQ_1730959314252.png)

## 线程池中有哪些常见的阻塞队列

1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。
2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。
3.DelayedWorkQueue：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的
4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。

![QQ_1730959405789](java面试题合集.assets/QQ_1730959405789.png)



## Threadlocal的理解

`ThreadLocal` 是 Java 中提供的一种用于存储线程局部变量的机制，使每个线程都能拥有自己的独立变量副本，从而避免线程之间对同一个变量的竞争和干扰。

同时实现了线程内的资源共享

`ThreadLocal` 变量的实际存储是通过每个线程内部的 `ThreadLocalMap` 实现的。每个线程维护一个 `ThreadLocalMap`，用于存储 `ThreadLocal` 变量的值。通过set，get，remove来获得或者删除值



## Java中线程的状态

**new -> runnable -> blocked ->waiting -> time waiting -> terminated**

1. **NEW**

- **描述**：当线程对象被创建但还没有调用 `start()` 方法时，线程处于 `NEW` 状态。
- **实例**：`Thread t = new Thread();` 此时线程 `t` 还未启动，所以它处于 `NEW` 状态。

2. **RUNNABLE**

- **描述**：当线程调用了 `start()` 方法，线程进入 `RUNNABLE` 状态。处于此状态的线程是正在准备或等待被分配到CPU执行的。此状态表示线程可能正在运行，也可能在等待CPU资源。
- **实例**：线程进入 `RUNNABLE` 状态后，如果获得了CPU资源，它就会开始执行自己的任务。

3. **BLOCKED**

- **描述**：当线程试图获得一个对象锁（monitor lock）而该锁被其他线程持有时，线程进入 `BLOCKED` 状态。这种状态通常发生在使用 `synchronized` 代码块或方法时，如果当前线程无法获得锁，它就会进入 `BLOCKED` 状态。
- **实例**：当两个线程都试图进入一个同步代码块（如` synchronized` 方法）时，只有一个线程可以获得锁，而另一个线程会进入 `BLOCKED` 状态。

4. **WAITING**

- **描述**：当线程执行 `wait()` 方法时，进入 `WAITING` 状态。线程进入此状态后，将一直等待直到其他线程显式地唤醒它。线程会等待其他线程调用 `notify()` 或 `notifyAll()` 方法来将其唤醒。
- **实例**：在线程中调用 `object.wait()` 后，当前线程进入 `WAITING` 状态，等待 `notify()` 或 `notifyAll()`。

5. **TIMED_WAITING**

- **描述**：当线程调用带有超时参数的 `sleep()`、`wait()`、`join()` 等方法时，进入 `TIMED_WAITING` 状态。线程在此状态下会等待一段时间，超过时间后会自动返回 `RUNNABLE` 状态。
- **实例**：`Thread.sleep(1000);` 让线程等待1秒钟，然后恢复运行。

6. **TERMINATED**

- **描述**：当线程的 `run()` 方法或 `call()` 方法执行完成后，线程进入 `TERMINATED` 状态。表示线程生命周期结束，无法再重新启动。
- **实例**：线程执行完所有任务后进入 `TERMINATED` 状态。此状态表示线程生命周期已经结束。

## 阻塞线程的方式有哪些？

wait和sleep和join



## java中 wait和sleep有什么区别

**共同点：**

wait(), wait(long), sleep()的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态

**不同点：**

- **所属类不同**

  - **`wait()`**：是 `Object` 类中的方法，因为它是线程间通信机制的一部分，允许线程在对象监视器上等待。

  - **`sleep()`**：是 `Thread` 类中的静态方法，与任何特定对象无关，仅用于让当前线程休眠一段时间。

- **锁的影响**

  - **`wait()`**：wait需要配合对象锁来使用，不加锁不能用。在释放锁的状态下，其他线程可以获得该锁并继续执行同步代码。

  - **`sleep()`**：调用 `sleep()` 后，线程不会释放锁，只是让出 CPU 执行权。在 `sleep()` 期间，其他线程无法获取该线程所持有的锁资源。

- **恢复方式不同**

  - **`wait()`**：需要其他线程调用 `notify()` 或 `notifyAll()` 来唤醒（可被指定对象的锁释放后恢复），否则线程会一直处于等待状态。
  - **`sleep()`**：会在指定的时间结束后自动恢复，无需其他线程的干预，也不涉及锁的释放

## java中 notify 和 notifyAll 区别

`notify` 方法

- **作用**：唤醒一个等待在该对象锁上的线程。如果有多个线程在等待这个锁，`notify` 只会随机选择一个线程进行唤醒。

`notifyAll` 方法

- **作用**：唤醒所有等待在该对象锁上的线程。被唤醒的线程会继续争夺锁，只有一个线程能获得锁并继续执行，其他线程则会再次进入等待状态，直到获得锁。



## synchronized的实现原理

`synchronized` 是通过对象锁机制来实现同步的。

`synchronized` 的实现依赖于 JVM 内部的**监视器锁（Monitor）**机制。在 Java 虚拟机（JVM）中，`synchronized` 关键字会在方法调用前或代码块执行前尝试获取目标对象的监视器锁，并在方法或代码块执行结束后释放锁。

![QQ_1730951790849](java面试题合集.assets/QQ_1730951790849.png)

在锁对象的时候，会先进入Monitor，判断里面的Owner是否为空，如果为空说明没有锁占用。否则加入EntryList并阻塞。如果调用了wait方法，会进入WaitSet，处于等待状态。



## synchronized的锁升级

Java 中的 synchronized 具有**⾃适应能⼒**。内部会⾃动评估当前锁冲突的剧烈程。

乐观锁/轻量级锁-》⾃旋锁 -》悲观锁/重量级锁/挂起等待锁。

- **乐观锁（Optimistic Locking）**

乐观锁基于这样一种假设：多个线程对同一资源的访问大部分情况下不会发生冲突（即不同时修改相同资源）。因此，在没有冲突的情况下，不会直接锁定资源，而是采用一种"先执行操作，后检查"的机制。乐观锁通常使用**CAS（Compare-And-Swap）操作**实现。



## 谈谈你对volatile的理解

1. 保证线程间的可见性

   volatile首先的一个功能就是保证了被修饰的变量在多线程环境下的可见性。用volatile修饰共享变量，能够防止编译器等优化发生，让一个线程对变量的修改对另一个线程可见

2. 禁止进行指令重排序

​	用volatile修饰的共享变量在读写共享变量的时候加入不同的屏障，组织其他读写操作	越过屏障，从而达到组织重排序的效果。

## 什么是AQS？

<img src="java面试题合集.assets/QQ_1730955563344.png" alt="QQ_1730955563344" style="zoom:67%;" />

- AQS是多线程中的队列同步器。是一种锁机制，它是做为一个基础框架使用的，像ReentrantLock、Semaphore都是基于AQS实现的
- AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程
- 在AQS内部还有一个属性state，这个state就相当于是一个资源，默认是0（无锁状态），如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源

## 谈谈ReentrantLock的理解

ReentrantLock相对于synchronized：

- 可中断
- 可设置超时时间
- 可以设置公平锁
- 支持多个条件变量
- 都支持重入，调用lock后再次调用lock是不会阻塞的

ReentrantLock底层主要是基于AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。

```java
// 创建锁对象
ReentrantLock lock = new ReentrantLock();
try{
	//获取锁
	lock.lock()
}finally{
	//释放锁
	lock.unlock()
}
```



## synchronized和lock有什么区别？

- 语法层面
  synchronized 是关键字，源码在jvm 中，用c++语言实现
  Lock 是接口，源码由jdk 提供，用java 语言实现
  使用 synchronized 时，退出同步代码块锁会自动释放，而使用Lock 时，需要手动调用 unlock 方法释放锁
- 功能层面
  二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能
  Lock 提供了许多 synchronized 不具备的功能，例如公平锁、可打断、可超时、多条件变量
  Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock（读写锁）
- 性能层面
  在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖
  在竞争激烈时，Lock 的实现通常会提供更好的性能

# JVM

## 类加载

1. 加载

“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事情：

- 通过一个类的全限定名来获取定义此类的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。



# MySQL

## Mysql**的三种存储引擎**

MyISAM：不⽀持事务，不⽀持外键，表锁

InnoDB：遵循ACID模型，⽀持事务，⾏级锁，⽀持外键

Memory：临时存储的引擎，不⽀持持久化，但是访问速度快



## **什么是聚簇索引什么是⾮聚簇索引？**

聚簇索引：将数据存储与索引放到⼀块，索引结构的叶⼦节点保存了⾏数据，是必须有且只能有⼀个的索引

⼆级索引：将数据存储与索引分开，索引结构的叶⼦节点关联的是对应的主键，可以存在多个

聚簇索引选取规则：

如果存在主键，主键索引就是聚簇索引

如果不存在主键，将使⽤第⼀个UNIQUE索引作为聚簇索引

如果表没有主键，或没有合适的唯⼀索引，InnoDB会⾃动⽣成⼀个rowid作为隐藏的聚簇索引

## **覆盖索引和联合索引**

覆盖索引：查询使⽤了索引，并且需要返回的列在该索引中都能找到

联合索引：针对覆盖索引需要的列，将它们联合变成⼀个⼆级索引，防⽌回表查询

## Mysql**的隔离级别**

1. 读未提交：事务可以读取未提交的数据，可能会读到脏数据，会导致幻读、不可重 复读、脏读等问题；
2. 读已提交：只能读取已经提交的数据，可以避免脏读问题，但是可能会遇到不可重复 读、幻读问题；
3. 可重复读：保证同⼀个事务中多次读取同⼀数据的结果是⼀致的，避免了脏读和不可重 复读问题，但是可能会遇到幻读问题；

4. 序列化：最⾼的隔离级别，可以避免所有并发问题，但是并发性能⾮常低，开销很⼤。

MySQL 的默认隔离级别是可重复读（Repeatable Read）。 其中，脏读指⼀个事务读到了另⼀个事务未提交的数据，不可重复读指同⼀个事务多次读取同⼀数据得到不同结果，幻读指同⼀个事务前后读取的数据集合不⼀致。



## 可重复读的具体实现

多版本并发控制（MVCC）

- **隐藏列**：InnoDB的每行数据有两个隐藏列（`事务id` 和 `回滚指针`）来记录版本信息。`事务id`用于记录最后一个修改该行的事务ID，而`回滚指针`指向回滚日志，用于找到数据的旧版本

- **undo log日志**：每次执行事务都会进行记录。会保存多个版本并行成一个版本链，通过回滚指针进行维护

- **锁的概念**：在可重复读隔离级别下，InnoDB不仅会对读取的数据行加锁，还会对这些行之间的“间隙”加锁。这样，即使其他事务试图在这些间隙中插入新数据，也会被阻止，从而保证查询结果集的一致性。

- ReadView：就是解决事务查询版本的问题

## acid**四⼤原则**

1. 原⼦性 Atomicity：事务是⼀个原⼦操作，要么全部提交，要么全部回滚。当⼀个事务执⾏期间发⽣故 障，操作系统会⾃动将其回滚到事务执⾏之前的状态，保证数据的⼀致性。

2. ⼀致性 Consistency：事务执⾏结束后，数据必须保持⼀致性状态。在事务执⾏期间，数据库中的数据可 以处于中间状态，但在事务完成时必须保证数据的⼀致性。

3. 隔离性 Isolation：数据库系统必须保证事务之间相互隔离，不会互相⼲扰。隔离级别不同，会影响到事务 的并发性和数据⼀致性，⽐如出现脏读、不可重复读、幻读等问题。

4. 持久性 Durability：⼀旦事务提交，其所做的修改必须永久保存到数据库中。即使系统发⽣故障或宕机， 数据也能够保持不变。



## SQL**优化**

1. 表的设计优化，合适的数值，字符串类型
2. sql语句优化，避免使⽤select *，避免索引失效，尽量使⽤union all
3. 分库分表
4. 使⽤关键词explain来确定索引效率



## **最左前缀法则**

最左前缀匹配原则是指如果⼀个联合索引包含了多个列，那么在查询时只能使⽤前⾯的列进⾏匹配。 例如，⼀个联合索引包含了 A、B、C 三列，那么查询时只能使⽤ A、AB 或 ABC 进⾏匹配，⽽不能只使⽤ B 或 C 进⾏匹配。这是因为如果查询时使⽤的列不是最左前缀列，那么 MySQL 就⽆法使⽤索引进⾏查询，会导致全表扫描，从⽽降低查询效率

## **索引失效**

1. 违反最左前缀法则
2. 范围查询右边的列，不能使⽤索引
3. 不要在索引上进⾏运算操作
4. 不要使⽤%开头的模糊匹配



## **讲 ⼀下**Union**和**Cross **查询**

**cross join** 连接⽤于从两个或者多个连接表中返回记录集的笛卡尔积，即将左表的每⼀⾏与右表的每⼀⾏合并

**UNION**: ⽤于合并两个或多个SELECT语句的结果集，并删除重复的⾏。它会对结果集进⾏排序。

**UNION ALL:** 与UNION类似，但它不会删除重复的⾏，也不会对结果集进⾏排序。因此，它通常⽐UNION更快。



## mysql**索引结构** B+

MySQL 之所以采⽤ B+ 树作为索引的实现⽅式，主要是因为 B+ 树具有以下优点：

能够⽀持⾼效的范围查找和排序。

叶⼦节点之间使⽤指针相连，能够⽀持⾼效的区间查询。

B+ 树具有较⾼的数据密度，可以减少磁盘 I/O 次数，提⾼查询效率。

B+ 树对于插⼊和删除操作也⽐较⾼效。

（B树：所有节点都存数据）



## 为什么用B+树而不是B树

1. B+树的数据存在叶子节点，而B树存在所有的节点下面
2. B+树的叶子节点使用了双向链表维护，能够⽀持⾼效的区间查询。

## 为什么用B+树而不是红黑树

1. B+树是多路平衡树，而红黑树是二叉平衡树。红黑树的一个节点只能有两个子节点，而B+树一个节点可以存多个值。所以相对比红黑树的深度和宽度都会更大，增加查找速度。
2. B+树的叶子节点使用了双向链表维护，能够⽀持⾼效的区间查询。红黑树没有链表结构，区间查找必须在多个子树之间递归查找
3. 因为B+树的结构只有在分裂或者合并的时候才会调整树结构，平常数据都是存储在叶子节点，内部节点只存储索引，所以可以避免平衡调整，降低数据维护开销。而红黑树因为是二叉树，所以每次添加都需要不断的自旋来进行平衡。

##  红⿊树

红⿊树是⼀种⾃平衡的⼆叉搜索树（BST）：

\- 节点要么是红⾊，要么是⿊⾊的

\- 根节点是⿊⾊

\- 叶⼦节点（没有⼦节点的节点）都是⿊⾊的空节点

\- 红⿊树中，红⾊节点的⼦节点都是⿊⾊的

\- 从任⼀节点到叶⼦节点的所有路径都包含相同数⽬的⿊节点

在添加和删除节点的时候，如果不满⾜当前条件就会发⽣旋转，来求平衡

## MySQL **⽇志**

binlog：即存档⽇志，事务执⾏时会把所有操作写⼊binlog，主要**用于数据备份**和主从复制；

redolog：即重做⽇志，修改了数据，那么事务提交前，⾸先会被记录成redo⽇志写⼊磁盘。实现了事务中的**持久性**，主要**用于掉电等故障恢复**；

- 记录的是数据页的物理变化，比如**对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新**，服务器宕机时可以用来同步数据。

uodolog：即回滚⽇志，是 Innodb 存储引擎层的⽇志，实现了事务中的**原子性**，主要**用于事务回滚和 MVCC**。

- undolog记录的是逻辑日志，每当我们执行一个操作的时候，undolog会记录一条与之相反的操作。当我们执行rollback的时候，就可以直接从undolog里读取到相应的内容



## mysql主从同步的原理

**Binary Log（binlog）**：主服务器将数据的变更操作记录到二进制日志（binlog）中，以供从服务器读取。binlog记录了每一次修改数据库的操作，如`INSERT`、`UPDATE`、`DELETE`等。

**Relay Log（中继日志）**：从服务器将主服务器的binlog复制到自己的Relay Log中，以便在从服务器上重放这些操作。



利用主库的binlog 日志，读取里面的操作然后写入副库的中继日志relay log中。然后副库读取relay log再去写入自己的库中。

## sql**执⾏顺序**

⾸先定表（from），然后分组过滤（where）

FROM、WHERE、GROUP BY、HAVING、SELECT、DISTINCT、ORDER BY、LIMIT/OFFSET

# 消息中间件

## RabbitMq消息丢失问题

1. 开启生产者确认机制，确保生产者的消息能够到达队列
2. 开启持久化功能，将队列，交换机和消息都持久化
3. 开启消费者确认机制为auto，有spring确认消息确认处理成功后发送ack
4. 开启消费者失败重试机制，多次失败后将消息投递到异常消息队列，然后报错。



# Srping

## Spring **的两⼤核⼼概念是什么？**

控制反转指的是将对象的创建和依赖注⼊由应⽤代码转移到了 Spring 容器中进⾏，即由 Spring 容器负责创建对象和管理它们之间的依赖关系。这样，应⽤代码只需要关注业务逻辑的实现，⽽不需要关注对象的创建和管理，降低了应⽤代码的复杂度，提⾼了代码的可重⽤性和可维护性。

⾯向切⾯编程是指将与业务逻辑⽆关的代码（如⽇志、安全、事务等）从业务逻辑中剥离出来，以便于统⼀管理和维护。

## springboot**⾃动配置的原理**

通过在application类上⾯加⼊@SpringBootApplication的注解，我们可以让springboot去进⾏bean的⾃动装配。

其实@SpringBootApplication是⼀个复核注解，它⾥⾯有许多的注解⽐如:

```java
@SpringBootConfiguration #该注解与@Configuration注解相同，⽤来声明这是个配置类
@EnableAutoConfiguration #springboot⾃动化配置核⼼注解
@ComponentScan #组件扫描，默认扫描当前引导类所在包及其⼦包
public @interface SpringBootApplication
```

其中真正实现⾃动装配的是注解@EnableAutoConfiguration，它由两个注解组成，⼀个是@AutoConfigurationPackage⽤来扫描当前所在包内所有的组件并加载到spring容器中，然后会由@import注解来导⼊对应的配置选择器。

内部就是读取了META-INF⽂件中关于配置类的定义，然后会根据预先设定好的条件，也就是@ConditionalOnClass注解来判断是否需要加载类。

## Srping 框架中的单例bean是线程安全的吗？

**不是线程安全的**
Spring框架中有一个@Scope注解，默认的值就是singleton，单例的。
因为一般在spring的bean的中都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决

## @Autowired**和** @Resource

@Autowired 是 Spring 提供的注解， @Resource 是 JDK 提供的注解。 Autowired 默认的注⼊⽅式为 byType（根据类型进⾏匹配）， @Resource 默认注⼊⽅式为byName （根据 名称进⾏匹配）。



## 如果想要实现自定义注入的话，怎么做？

使用Qualifier注解指定实现类，就是我们针对我们的方法进行指定的命名，然后在Autowired的时候使用@Qualifier("serviceA")来指定我们要注入的方法名

## Spring**中的事务是怎么实现的**

spring⽀持编程式事务管理和声明式事务管理两种⽅式

编程式事务控制：需要使⽤TransactionTemplate来进⾏实现，对业务代码有侵⼊性，很少使⽤

声明式事务管理：建⽴在AOP机制上，本质是通过AOP对⽅法前后进⾏拦截，在⽬标⽅法开始前加⼊事务，

执⾏完毕后根据情况回滚或提交。关键字@Transactional。底层数据结构是代理模式。

## Spring API**项⽬中**AOP**的具体处理细节**

AOP的处理时机分为（Before 前置处理）（After 后置处理）（Around 环绕处理）（AfterReturnning 后置返回通知）等在API项⽬中，我们使⽤AOP实现了登⼊权限拦截，通过使⽤环

Spring AOP 底层主要通过两种动态代理方式来实现：**JDK 动态代理** 和 **CGLIB 动态代理**。

- JDK代理

  - JDK 动态代理只适用于**接口**，即目标对象必须实现一个或多个接口。
  - 通过反射的方式进行调用

-  CGLIB 动态代理

  - CGLIB 是通过继承方式生成子类来实现代理，因此不能代理 `final` 类或 `final` 方法。
  - 通过子类调用父类的方式进行调用

  ## spring是如何解决循环依赖的

  Spring 使用三级缓存（三级缓存注释如下）解决循环依赖问题。在 Spring 容器创建一个 bean 时，首先会将其放入不同级别的缓存中，以便其他依赖该 bean 的 bean 可以在创建过程中引用它。

  三个缓存层次：

  - **一级缓存**：`singletonObjects`，存储完全初始化完成的单例对象。
  - **二级缓存**：`earlySingletonObjects`，存储实例化但未完全初始化的单例对象。
  - **三级缓存**：`singletonFactories`，存储提前曝光的 bean 工厂，以便可以生成该 bean 的早期引用（通常通过代理）。

###### 

# Redis

## Redis的常见数据类型和应用场景

String (字符串) - 用户信息、配置信息

Hash (哈希) - 用户对象

List (列表) - 队列功能如消息队列

Set ( 无序集合，不允许重复元素) - 适用于标签、关注关系

Sorted Set (有序集合) - 适合实现排行榜

## Redis的过期策略

**定期删除 (Periodic Deletion)**

- Redis 默认每隔一段时间（100ms）随机抽取部分设置了过期时间的键进行检查和删除。
- 定期删除有助于清理内存，但会对系统资源有轻微影响。

优点：可以通过限制删除操作执行的市场和频率来降低删除对CPU的影响

缺点：难以确定删除操作执行的时长和评率

**惰性删除 (Lazy Deletion)**

- 当访问一个键时，Redis会检查其是否过期，如果过期则立即删除。
- 惰性删除可以避免频繁扫描，但是如果过期键长时间不被访问，可能会导致内存占用增长。

优点：对CPU友好，只会在使用到该key的时候进行过期检查

缺点：对内存不友好，如果一个key过期，但是一直没用到，就会一直存在内存中

## Redis的淘汰策略

当内存接近配置的最大限制时，Redis会根据不同的策略选择数据淘汰：

算法：

**LRU**（Least Recently Used）最近最少使用。用当前时间，减去最后一次访问时间，这个值越大淘汰优先级越高。

**LFU**（Least Frequently Used）最少频率使用。会统计每隔key的访问频率，值越少，越优先淘汰。



1. **noeviction**（不淘汰策略）：达到最大内存限制时，直接返回错误，不再执行任何写入操作。
2. **allkeys-lru**（最近最少使用）：基于最近最少使用（LRU）策略淘汰所有键中的最久未使用的键。
3. **volatile-lru**（最长未使用）：基于LRU算法，从设置了过期时间的键中淘汰最久未使用的键。
4. **allkeys-random**（随机淘汰）：随机淘汰所有键。
5. **volatile-random**（随机淘汰设置过期）：随机淘汰设置了过期时间的键。
6. **volatile-ttl**：优先淘汰即将过期的键（TTL最短的键）。

## 讲一下Redis分布式锁

**业务场景：**当我们在面对**优惠卷、秒杀等活动**的时候，为了**防止超额卖出**，我们会使用分布式锁

**原理：**使用Redisson来构建分布式锁，**先用setnx来加锁**，然后用**给锁加一个日期防止死锁**。最好一条指令setnx+expire，防止两条指令之间发生崩溃导致死锁。

## Redisson实现分布式锁怎么控制锁的有效时长？

Watch dog 看门狗：在一个线程获得锁后，watch dog会**每隔（release time/ 3）的时间会做一次续期**，之后释放锁只需要给watch dog传递参数就可以了

–     优点：自动延长时间



## Redisson的这个锁，可以重入吗？

**可以重入**，多个锁重入需要判断是否来自**同一线程**，在redis中使用**hash结构**在存储**线程信息和重入的次数**。



## 什么是缓存穿透 ? 

缓存穿透是指客户端请求的数据在**缓存和数据库中都不存在**，这样缓存永远不会生效，这些请求**每次都要到 DB 去查询**，可能导致 DB 挂掉。

解决方案的话有两种，分别是**缓存空对象**和**布隆过滤**

1. 缓存空对象
2. 布隆过滤

可以使用布隆过滤器解决。

核心思想是**通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在**，如果布隆过滤器判断存在，则放行，否则直接返回



## 什么是缓存击穿？

缓存击穿问题也叫热点Key问题，就是一个被**高并发访问**并且**缓存重建业务较复杂**的key突然失效了，**无数的请求访问会在瞬间给数据库带来巨大的冲击**。

常见的解决方案有两种：

•     ==互斥锁==

优点：强一致性

缺点：性能差

•     ==逻辑过期== 

优点：高可用性和高性能

缺点：不能保证数据一致性



## 什么是缓存雪崩 ？

缓存雪崩是指在同一时段大量的**缓存key同时失效**或者**Redis服务宕机**，导致大量请求到达数据库，带来巨大压力。

解决方案主要是可以将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。



## redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）

我们采用的是redisson实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。



## redis做为缓存，数据的持久化是怎么做的？

**Redis 提供两种持久化机制 RDB 和 AOF 机制:**

### 1.    RDB（Redis Database Backup file）Redis数据快照

简单来说就是把redis内存存储的数据**写到磁盘上**，当redis实例宕机恢复数据的时候，方便从**RDB的快照文件中恢复数据**。

**优点:**

1、只有一个文件 dump.rdb，方便持久化。 

2、容灾性好，一个文件可以保存到安全的磁盘。

3、性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能

4.相对于数据集大时，比 AOF 的启动效率更高。

**缺点:**

1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生 故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候

### 2.    AOF（Append-only file）追加文件

是指所有的命令行记录以 redis 命令请 求协议的格式完全持久化存储)保存为 aof 文件。

**优点：**

1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。

2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。

**缺点:**

1、AOF 文件比 RDB 文件大，且恢复速度慢。 

2、数据集大的时候，比 rdb 启动效率低。







# 网络

## tcp和udp的区别

TCP（Transmission Control Protocol）和 UDP（User Datagram Protocol）是两种常用的网络传输协议，主要区别在于数据传输的可靠性、连接的建立和性能。以下是它们的主要差异：

TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。

5. ## TCP 三次握手

<img src="java面试题合集.assets/image-20240422175115316.png" alt="image-20240422175115316" style="zoom:50%;" />

客户端向服务端发送syn 包，然后服务端同意链接则会向客户端发送syn + ack包，客户端收到后在发送ack包正式确定链接。

## TCP 四次挥手

![image-20241108171925006](java面试题合集.assets/image-20241108171925006.png)

第一次挥手：a发送FIN包并进入等待状态

第二次挥手：b收到，并发送ack包表示收到并进入等待关闭状态，而客户端则进入等待2状态

第三次挥手：待a发送完所有数据，b发送FIN包，并进入最终确认状态

第四次挥手：a回复ack包并进入超时等待状态，等待2被msl的时间。而服务端收到ack后就会断开连接

# 设计模式



## 六大软件设计原则

- 开闭原则（Open Closed Principle）

对扩展开放，对修改关闭。当程序需要扩展时，我们不能去修改原有代码，而是去扩充

- 单一职责原则（Single Responsibility Principle）

一个类或者模块只负责一个功能。来实现高内聚、低耦合的方针。

- 里氏替换原则（Liskov Substitution Principle）

子类对象能够替换程序中所有的父类对象。在我们子类继承父类时，不要去重写父类的实现方法。

- 迪米特法则（Law of Demeter）

一个对象应该对其他对象保持最小的了解

- 接口隔离原则（Interface Segregation Principle）

建立单一接口，不要建立冗余的接口，尽量细化并且减少接口中的方法

- 依赖倒置原则（Dependence Inversion Principle）

要依赖于抽象，不要依赖于具体，核心思想是面向接口编程



## 设计模式的类别

设计模式可以分为三类： 

1. 创建型模式：这类模式关注对象创建的机制，包括单例模式、⼯⼚模式、抽象⼯⼚模式、建造者模式和原型模 式等。 
2. 结构型模式：这类模式关注对象之间的组合关系，包括适配器模式、装饰器模式、代理模式、组合模式、桥接 模式、外观模式和享元模式等。 
3. ⾏为型模式：这类模式关注对象之间的通信⽅式和协作⽅式，包括模板⽅法模式、策略模式、命令模式、职责 链模式、状态模式、观察者模式、中介者模式和访问者模式等。

## 单例模式 

什么是单例模式？使⽤单例模式有什么好处？有哪些常⽤的单例模式实现⽅式？各⾃的应⽤场景是什么？

单例模式（Singleton Pattern）此模式保证某个类在运行期间，只有一个实例对外提供服务，而这个类被称为单例类

单例的好处有：

1. **节省内存空间**。单例模式只创建⼀个实例，避免了多次创建对象所造成的内存消耗。 
2. **简化代码**。单例模式提供了⼀个全局的访问点，可以⽅便地调⽤实例的⽅法，避免了重复的代码。 
3. **保证数据的⼀致性**。由于只有⼀个实例，可以避免并发访问时数据不⼀致的问题。

单例的实现方式：

- **饿汉式单例模式：**在类加载时就创建了实例，因此保证了线程安全。但是可能会造成资源浪费，因为实例在使 ⽤前就已经创建了。 

- **懒汉式单例模式：**实例的创建是在第⼀次使⽤时才进⾏的。这种⽅式需要注意线程安全，可以使⽤ synchronized 关键字或者双重检查锁定等⽅式来保证线程安全。

- **静态内部类单例模式：**这种⽅式可以保证线程安全，且实现简单。实例的创建是在第⼀次使⽤时才进⾏的。 

- **枚举单例模式：**这种⽅式可以保证线程安全，且实现简单。枚举类型的属性在 Java 中只会被初始化⼀次，因 此枚举单例模式可以保证只有⼀个实例。 

- **双重检查锁定单例模式：**这种⽅式可以保证线程安全，且实现相对简单。在第⼀次调⽤ getInstance()⽅法时 进⾏了双重检查，保证了只有⼀个实例被创建。 

- **线程局部变量单例模式：**这种⽅式可以保证线程安全，且实现简单。在单个线程内部只会创建⼀个实例，因此 不会造成资源浪费。

单例的使⽤场景：

1. **数据库连接池：**在多线程环境下，为了避免频繁地创建和释放数据库连接，可以使⽤单例模式来实现数据库连 接池，保证系统中只有⼀个连接池实例；
2. **应⽤程序配置信息对象：**在系统中需要读取应⽤程序配置信息时，为了避免重复读取和存储配置信息，可以使 ⽤单例模式来实现配置信息对象，保证系统中只有⼀个配置信息对象实例；



## 工厂模式

让⼀个专⻔的⼯⼚类负责创建对象实例，⽽不是在代码中直接使⽤ new 操作符。这有助于降低 代码的耦合度，提⾼可维护性和可扩展性。

- 简单⼯⼚模式 （⼀个⼯⼚⽣产所有的对象 ） 如果它负责的对象太多，简单⼯⼚容易庞⼤，变成超级类 简单⼯⼚的拓展是竖向拓展（拓展需要访问⼯⼚内部，职责不够单⼀） 因此，他适合在'简单场景' - 对象少且固定 

- ⼯⼚⽅法模式 （ ⼀个⼯⼚⼀个对象 ） ⼯⼚⽅法是横向拓展，由于⼯⼚对象1对1，耦合度没有任何减少，要⽣产类就要知道那个对应的⼯⼚ 当需要⽣产新的产品时，⽆需更改既有的⼯⼚，只需要添加新的⼯⼚即可。保持了⾯向对象的可扩展性(纵 向，横向都很不错)，符合开闭原则。 因此，⼯⼚⽅法模式适⽤于对象多⽽且可能增加的场景 

- 抽象⼯⼚模式 （ 抽象接⼝⼯⼚实现 ） 抽象⼯⼚是定义了⼀个接⼝，然后由具体⼯⼚去实现抽象⽅法，突出特点就是运⽤了多态，耦合够松。 缺点也很明显，在接⼝不变的情况下，⽆论是横向拓展性还是松耦合都很好，但是⼀旦接⼝有新的功能增加， 所有的⼯⼚实现都需要纵向拓展。即横向拓展能⼒强，但是纵向拓展能⼒=0 因此，抽象⼯⼚模式适合产品族（即有相似属性）的⽣产



## API项目中有用到设计模式吗？

API项目的话并没有用到设计模式，因为每个服务的功能比较单一，并不是特别好抽象。但是如果非要应用设计模式的话，可以通过适配器模式与桥接模式集成第三方登录功能,



适配器模式的话就是将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。







# 项目问题



Nignx 作为负载均衡，将请求发送到前端。 前端将请求发送给API网关，由网关进行限流并转发给后端



## 讲一下网关的作用

这里网关的话主要是想作为统一入口，提供路由转发、过滤、安全验证等功能

**路由转发**：

- 接收外界请求，通过网关的路由转发，转发到后端的服务上。

**访问控制与签名校验**：

- Gateway支持在请求进入网关时进行身份认证和访问控制，可以设置令牌验证、API签名校验等安全措施。你的项目中提到设计了API签名认证算法，为用户分配ak/sk实现鉴权。

**流量染色与限流**：

- 流量染色可以将不同来源、不同类型的请求“染色”标记，例如将测试环境和生产环境的请求区分开来，确保数据安全和环境隔离。

## nacos注册中心的作用

1. 服务注册：各个服务在启动时向注册中心注册自己的网络地址、服务实例信息和其他相关元数据。这样，其他服务就可以通过注册中心获取当前可用的服务列表
2. 服务发现：客户端通过向注册中心查询特定服务的注册信息，获得可用的服务实例列表。这样客户端就可以根据需要选择合适的服务进行调用、实现了服务间的解耦。
3. 负载均衡：注册中心可以对同一服务的多个实例进行负载均衡，将请求分发到不同的实例上，提高整体的系统性能和可用性。
4. 故障恢复：注册中心能够监测和检测服务的状态，当服务实例发生故障或下线时，可以及时更新注册信息，从而保证服务能够正常工作。
5. 服务治理：通过注册中心可以进行服务的配置管理、动态扩缩容、服务路由、灰度发布等操
   作，实现对服务的动态管理和控制。







## 说下Eureka、ZooKeeper、Nacos的区别

![QQ_1731302428702](java面试题合集.assets/QQ_1731302428702.png)

总结：
在选择微服务注册中心时，需要根据实际需求进行综合考虑。ZooKeeper适用于需要高度自定义和强一致性的场景；Eureka适用于需要快速迭代和易于维护的中小型微服务项目；Consul适用于需要高性能和可扩展的大型微服务项目；而Nacos则适用于需要一站式解决方案的云原生应用开发。











































